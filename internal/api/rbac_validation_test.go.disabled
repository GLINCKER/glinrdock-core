package api

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/GLINCKER/glinrdock/internal/store"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
)

// Using CreateTokenRequest from tokens.go

// Test RBAC validation functions directly without complex dependencies
func TestRBACValidation_RoleChecking(t *testing.T) {
	tests := []struct {
		role  string
		valid bool
		desc  string
	}{
		{store.RoleAdmin, true, "admin role is valid"},
		{store.RoleDeployer, true, "deployer role is valid"},
		{store.RoleViewer, true, "viewer role is valid"},
		{"invalid", false, "invalid role"},
		{"ADMIN", false, "case sensitive"},
		{"", false, "empty role"},
		{" admin", false, "leading space"},
		{"admin ", false, "trailing space"},
	}

	for _, test := range tests {
		t.Run(test.desc, func(t *testing.T) {
			result := store.IsRoleValid(test.role)
			assert.Equal(t, test.valid, result)
		})
	}
}

func TestRBACValidation_PermissionChecking(t *testing.T) {
	tests := []struct {
		userRole   string
		targetRole string
		canAccess  bool
		desc       string
	}{
		// Admin can access all
		{store.RoleAdmin, store.RoleAdmin, true, "admin can access admin resources"},
		{store.RoleAdmin, store.RoleDeployer, true, "admin can access deployer resources"},
		{store.RoleAdmin, store.RoleViewer, true, "admin can access viewer resources"},

		// Deployer can access deployer and viewer
		{store.RoleDeployer, store.RoleAdmin, false, "deployer cannot access admin resources"},
		{store.RoleDeployer, store.RoleDeployer, true, "deployer can access deployer resources"},
		{store.RoleDeployer, store.RoleViewer, true, "deployer can access viewer resources"},

		// Viewer can only access viewer
		{store.RoleViewer, store.RoleAdmin, false, "viewer cannot access admin resources"},
		{store.RoleViewer, store.RoleDeployer, false, "viewer cannot access deployer resources"},
		{store.RoleViewer, store.RoleViewer, true, "viewer can access viewer resources"},
	}

	for _, test := range tests {
		t.Run(test.desc, func(t *testing.T) {
			result := store.CanAccessResource(test.userRole, test.targetRole)
			assert.Equal(t, test.canAccess, result)
		})
	}
}

func TestRBACValidation_TokenCreationPermissions(t *testing.T) {
	tests := []struct {
		userRole   string
		targetRole string
		canCreate  bool
		desc       string
	}{
		// Only admin can create tokens
		{store.RoleAdmin, store.RoleAdmin, true, "admin can create admin tokens"},
		{store.RoleAdmin, store.RoleDeployer, true, "admin can create deployer tokens"},
		{store.RoleAdmin, store.RoleViewer, true, "admin can create viewer tokens"},
		{store.RoleAdmin, "invalid", false, "admin cannot create invalid role tokens"},

		// Non-admin cannot create any tokens
		{store.RoleDeployer, store.RoleAdmin, false, "deployer cannot create admin tokens"},
		{store.RoleDeployer, store.RoleDeployer, false, "deployer cannot create deployer tokens"},
		{store.RoleDeployer, store.RoleViewer, false, "deployer cannot create viewer tokens"},

		{store.RoleViewer, store.RoleAdmin, false, "viewer cannot create admin tokens"},
		{store.RoleViewer, store.RoleDeployer, false, "viewer cannot create deployer tokens"},
		{store.RoleViewer, store.RoleViewer, false, "viewer cannot create viewer tokens"},
	}

	for _, test := range tests {
		t.Run(test.desc, func(t *testing.T) {
			result := store.CanCreateRole(test.userRole, test.targetRole)
			assert.Equal(t, test.canCreate, result)
		})
	}
}

// Test middleware behavior with mock contexts
func TestRBACValidation_MiddlewareRoleExtraction(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		setRole      string
		expectedRole string
		desc         string
	}{
		{store.RoleAdmin, store.RoleAdmin, "admin role extraction"},
		{store.RoleDeployer, store.RoleDeployer, "deployer role extraction"},
		{store.RoleViewer, store.RoleViewer, "viewer role extraction"},
		{"", "", "empty role extraction"},
	}

	for _, test := range tests {
		t.Run(test.desc, func(t *testing.T) {
			w := httptest.NewRecorder()
			c, _ := gin.CreateTestContext(w)

			if test.setRole != "" {
				c.Set("token_role", test.setRole)
			}

			// Test CurrentRole function from auth package
			// We'll implement a simple version here for testing
			role, exists := c.Get("token_role")
			if !exists {
				assert.Equal(t, "", test.expectedRole)
			} else {
				assert.Equal(t, test.expectedRole, role.(string))
			}
		})
	}
}

// Test JSON request validation
func TestRBACValidation_CreateTokenRequestValidation(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		reqBody    map[string]interface{}
		expectCode int
		expectMsg  string
		desc       string
	}{
		{
			reqBody:    map[string]interface{}{"name": "test-token", "plain": "secret", "role": store.RoleAdmin},
			expectCode: http.StatusOK, // Would be OK if handler processes it
			expectMsg:  "",
			desc:       "valid request",
		},
		{
			reqBody:    map[string]interface{}{"name": "", "plain": "secret", "role": store.RoleAdmin},
			expectCode: http.StatusBadRequest,
			expectMsg:  "required",
			desc:       "empty name",
		},
		{
			reqBody:    map[string]interface{}{"name": "test", "plain": "", "role": store.RoleAdmin},
			expectCode: http.StatusBadRequest,
			expectMsg:  "required",
			desc:       "empty plain",
		},
		{
			reqBody:    map[string]interface{}{"name": "test", "plain": "secret", "role": "invalid"},
			expectCode: http.StatusBadRequest,
			expectMsg:  "role",
			desc:       "invalid role",
		},
	}

	for _, test := range tests {
		t.Run(test.desc, func(t *testing.T) {
			w := httptest.NewRecorder()
			c, _ := gin.CreateTestContext(w)

			bodyBytes, _ := json.Marshal(test.reqBody)
			c.Request = httptest.NewRequest("POST", "/", bytes.NewBuffer(bodyBytes))
			c.Request.Header.Set("Content-Type", "application/json")

			var req CreateTokenRequest
			err := c.ShouldBindJSON(&req)

			if test.expectCode == http.StatusBadRequest {
				if test.desc == "invalid role" {
					// Role validation would happen after JSON binding
					assert.NoError(t, err) // JSON binding succeeds
					assert.False(t, store.IsRoleValid(req.Role))
				} else {
					// JSON binding fails for required fields
					assert.Error(t, err)
				}
			} else {
				assert.NoError(t, err)
				assert.Equal(t, test.reqBody["name"], req.Name)
				assert.Equal(t, test.reqBody["plain"], req.Plain)
				assert.Equal(t, test.reqBody["role"], req.Role)
			}
		})
	}
}

func TestRBACValidation_DefaultRoleAssignment(t *testing.T) {
	tests := []struct {
		inputRole    string
		expectedRole string
		desc         string
	}{
		{"", store.RoleAdmin, "empty role defaults to admin"},
		{store.RoleAdmin, store.RoleAdmin, "admin role preserved"},
		{store.RoleDeployer, store.RoleDeployer, "deployer role preserved"},
		{store.RoleViewer, store.RoleViewer, "viewer role preserved"},
	}

	for _, test := range tests {
		t.Run(test.desc, func(t *testing.T) {
			req := CreateTokenRequest{
				Name:  "test-token",
				Plain: "secret",
				Role:  test.inputRole,
			}

			// Simulate the default role assignment logic from CreateToken handler
			if req.Role == "" {
				req.Role = store.RoleAdmin
			}

			assert.Equal(t, test.expectedRole, req.Role)
		})
	}
}
