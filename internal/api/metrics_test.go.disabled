package api

import (
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/GLINCKER/glinrdock/internal/metrics"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestMetricsHandlers_GetMetrics(t *testing.T) {
	// Create a test collector with some data
	collector := metrics.NewCollector()
	collector.SetServicesRunning(3)
	collector.IncActiveJobs()
	collector.RecordBuild(true, 30*time.Second)
	collector.RecordBuild(false, 45*time.Second)
	collector.RecordDeployment(true, 10*time.Second)

	// Create handlers
	handlers := NewMetricsHandlers(collector)

	// Setup Gin router
	gin.SetMode(gin.TestMode)
	router := gin.New()
	v1 := router.Group("/v1")
	handlers.RegisterRoutes(v1)

	// Create test request
	req := httptest.NewRequest(http.MethodGet, "/v1/metrics", nil)
	rec := httptest.NewRecorder()

	// Execute request
	router.ServeHTTP(rec, req)

	// Check response
	assert.Equal(t, http.StatusOK, rec.Code)

	body := rec.Body.String()

	// Check that all expected metrics are present in the output
	expectedMetrics := []string{
		"glinrdock_uptime_seconds",
		"glinrdock_services_running_total 3",
		"glinrdock_jobs_active 1",
		"glinrdock_builds_total{status=\"success\"} 1",
		"glinrdock_builds_total{status=\"failed\"} 1",
		"glinrdock_deployments_total{status=\"success\"} 1",
		"glinrdock_build_duration_seconds",
		"glinrdock_deploy_duration_seconds",
	}

	for _, expected := range expectedMetrics {
		assert.Contains(t, body, expected, "Expected metric %s not found in output", expected)
	}
}

func TestMetricsHandlers_GetMetrics_EmptyState(t *testing.T) {
	// Create a test collector with no data
	collector := metrics.NewCollector()

	// Create handlers
	handlers := NewMetricsHandlers(collector)

	// Setup Gin router
	gin.SetMode(gin.TestMode)
	router := gin.New()
	v1 := router.Group("/v1")
	handlers.RegisterRoutes(v1)

	// Create test request
	req := httptest.NewRequest(http.MethodGet, "/v1/metrics", nil)
	rec := httptest.NewRecorder()

	// Execute request
	router.ServeHTTP(rec, req)

	// Check response
	assert.Equal(t, http.StatusOK, rec.Code)

	body := rec.Body.String()

	// Check that metrics are present with zero values
	expectedPatterns := []string{
		"glinrdock_services_running_total 0",
		"glinrdock_jobs_active 0",
		"TYPE glinrdock_uptime_seconds gauge",
		"TYPE glinrdock_builds_total counter",
		"TYPE glinrdock_deployments_total counter",
		"TYPE glinrdock_build_duration_seconds histogram",
		"TYPE glinrdock_deploy_duration_seconds histogram",
	}

	for _, expected := range expectedPatterns {
		assert.Contains(t, body, expected, "Expected pattern %s not found in output", expected)
	}
}

func TestMetricsHandlers_PrometheusFormat(t *testing.T) {
	// Create a test collector
	collector := metrics.NewCollector()

	// Create handlers
	handlers := NewMetricsHandlers(collector)

	// Setup Gin router
	gin.SetMode(gin.TestMode)
	router := gin.New()
	v1 := router.Group("/v1")
	handlers.RegisterRoutes(v1)

	// Create test request
	req := httptest.NewRequest(http.MethodGet, "/v1/metrics", nil)
	rec := httptest.NewRecorder()

	// Execute request
	router.ServeHTTP(rec, req)

	// Check response
	assert.Equal(t, http.StatusOK, rec.Code)

	// Check Content-Type header
	contentType := rec.Header().Get("Content-Type")
	assert.Contains(t, contentType, "text/plain")

	body := rec.Body.String()

	// Check basic Prometheus format structure
	assert.Contains(t, body, "# HELP")
	assert.Contains(t, body, "# TYPE")

	// Should not be JSON
	assert.False(t, strings.HasPrefix(body, "{"), "Response should not be JSON")

	// Should contain metric names
	assert.Contains(t, body, "glinrdock_")
}

func TestMetricsHandlers_RegisterRoutes(t *testing.T) {
	collector := metrics.NewCollector()
	handlers := NewMetricsHandlers(collector)

	// Setup Gin router
	gin.SetMode(gin.TestMode)
	router := gin.New()
	v1 := router.Group("/v1")

	// Register routes
	handlers.RegisterRoutes(v1)

	// Get all routes
	routes := router.Routes()

	// Find the metrics route
	found := false
	for _, route := range routes {
		if route.Path == "/v1/metrics" && route.Method == "GET" {
			found = true
			break
		}
	}

	assert.True(t, found, "Metrics route not registered correctly")
}

func TestMetricsHandlers_MultipleRequests(t *testing.T) {
	// Create a test collector
	collector := metrics.NewCollector()

	// Create handlers
	handlers := NewMetricsHandlers(collector)

	// Setup Gin router
	gin.SetMode(gin.TestMode)
	router := gin.New()
	v1 := router.Group("/v1")
	handlers.RegisterRoutes(v1)

	// Make first request
	req1 := httptest.NewRequest(http.MethodGet, "/v1/metrics", nil)
	rec1 := httptest.NewRecorder()
	router.ServeHTTP(rec1, req1)

	assert.Equal(t, http.StatusOK, rec1.Code)
	body1 := rec1.Body.String()

	// Update some metrics
	collector.SetServicesRunning(5)
	collector.IncActiveJobs()

	// Make second request
	req2 := httptest.NewRequest(http.MethodGet, "/v1/metrics", nil)
	rec2 := httptest.NewRecorder()
	router.ServeHTTP(rec2, req2)

	assert.Equal(t, http.StatusOK, rec2.Code)
	body2 := rec2.Body.String()

	// Second response should reflect the updated metrics
	assert.Contains(t, body2, "glinrdock_services_running_total 5")
	assert.Contains(t, body2, "glinrdock_jobs_active 1")

	// Responses should be different
	assert.NotEqual(t, body1, body2)
}

func TestMetricsHandlers_InvalidMethod(t *testing.T) {
	collector := metrics.NewCollector()
	handlers := NewMetricsHandlers(collector)

	// Setup Gin router
	gin.SetMode(gin.TestMode)
	router := gin.New()
	v1 := router.Group("/v1")
	handlers.RegisterRoutes(v1)

	// Test POST request (should not be allowed)
	req := httptest.NewRequest(http.MethodPost, "/v1/metrics", nil)
	rec := httptest.NewRecorder()

	router.ServeHTTP(rec, req)

	// Should return 404 (method not allowed)
	assert.Equal(t, http.StatusNotFound, rec.Code)
}

func TestNewMetricsHandlers(t *testing.T) {
	collector := metrics.NewCollector()
	handlers := NewMetricsHandlers(collector)

	require.NotNil(t, handlers)
	require.NotNil(t, handlers.collector)
	assert.Same(t, collector, handlers.collector)
}
