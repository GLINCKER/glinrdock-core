package api

import (
	"bytes"
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/GLINCKER/glinrdock/internal/jobs"
	"github.com/GLINCKER/glinrdock/internal/store"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

// Mock stores for testing
type MockBuildStore struct {
	mock.Mock
}

func (m *MockBuildStore) CreateBuild(ctx context.Context, build *store.Build) error {
	args := m.Called(ctx, build)
	// Set ID for created build
	build.ID = 1
	return args.Error(0)
}

func (m *MockBuildStore) GetBuild(ctx context.Context, buildID int64) (*store.Build, error) {
	args := m.Called(ctx, buildID)
	if build := args.Get(0); build != nil {
		return build.(*store.Build), args.Error(1)
	}
	return nil, args.Error(1)
}

func (m *MockBuildStore) ListBuilds(ctx context.Context, serviceID int64) ([]*store.Build, error) {
	args := m.Called(ctx, serviceID)
	if builds := args.Get(0); builds != nil {
		return builds.([]*store.Build), args.Error(1)
	}
	return nil, args.Error(1)
}

func (m *MockBuildStore) UpdateBuildStatus(ctx context.Context, buildID int64, status string, logPath *string, startedAt, finishedAt *int64) error {
	args := m.Called(ctx, buildID, status, logPath, startedAt, finishedAt)
	return args.Error(0)
}

type MockDeploymentStore struct {
	mock.Mock
}

func (m *MockDeploymentStore) CreateDeployment(ctx context.Context, deployment *store.Deployment) error {
	args := m.Called(ctx, deployment)
	// Set ID for created deployment
	deployment.ID = 1
	return args.Error(0)
}

func (m *MockDeploymentStore) GetDeployment(ctx context.Context, deploymentID int64) (*store.Deployment, error) {
	args := m.Called(ctx, deploymentID)
	if deployment := args.Get(0); deployment != nil {
		return deployment.(*store.Deployment), args.Error(1)
	}
	return nil, args.Error(1)
}

func (m *MockDeploymentStore) ListDeployments(ctx context.Context, serviceID int64) ([]*store.Deployment, error) {
	args := m.Called(ctx, serviceID)
	if deployments := args.Get(0); deployments != nil {
		return deployments.([]*store.Deployment), args.Error(1)
	}
	return nil, args.Error(1)
}

func (m *MockDeploymentStore) GetLatestDeployment(ctx context.Context, serviceID int64) (*store.Deployment, error) {
	args := m.Called(ctx, serviceID)
	if deployment := args.Get(0); deployment != nil {
		return deployment.(*store.Deployment), args.Error(1)
	}
	return nil, args.Error(1)
}

func (m *MockDeploymentStore) UpdateDeploymentStatus(ctx context.Context, deploymentID int64, status string, reason *string) error {
	args := m.Called(ctx, deploymentID, status, reason)
	return args.Error(0)
}

type MockCICDServiceStore struct {
	mock.Mock
}

func (m *MockCICDServiceStore) GetService(ctx context.Context, serviceID int64) (*store.Service, error) {
	args := m.Called(ctx, serviceID)
	if service := args.Get(0); service != nil {
		return service.(*store.Service), args.Error(1)
	}
	return nil, args.Error(1)
}

func (m *MockCICDServiceStore) CreateService(ctx context.Context, service *store.Service) error {
	args := m.Called(ctx, service)
	return args.Error(0)
}

func (m *MockCICDServiceStore) UpdateService(ctx context.Context, serviceID int64, updates map[string]interface{}) error {
	args := m.Called(ctx, serviceID, updates)
	return args.Error(0)
}

func (m *MockCICDServiceStore) DeleteService(ctx context.Context, serviceID int64) error {
	args := m.Called(ctx, serviceID)
	return args.Error(0)
}

func (m *MockCICDServiceStore) ListServices(ctx context.Context, projectID int64) ([]store.Service, error) {
	args := m.Called(ctx, projectID)
	if services := args.Get(0); services != nil {
		return services.([]store.Service), args.Error(1)
	}
	return nil, args.Error(1)
}

type MockCICDProjectStore struct {
	mock.Mock
}

func (m *MockCICDProjectStore) ListProjects(ctx context.Context) ([]store.Project, error) {
	args := m.Called(ctx)
	return args.Get(0).([]store.Project), args.Error(1)
}

func (m *MockCICDProjectStore) GetProject(ctx context.Context, id int64) (store.Project, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(store.Project), args.Error(1)
}

func setupCICDHandlers() (*CICDHandlers, *MockBuildStore, *MockDeploymentStore, *MockCICDServiceStore, *jobs.Queue) {
	buildStore := &MockBuildStore{}
	deploymentStore := &MockDeploymentStore{}
	serviceStore := &MockCICDServiceStore{}
	projectStore := &MockCICDProjectStore{}
	jobQueue := jobs.NewQueue(1)

	handlers := NewCICDHandlers(buildStore, deploymentStore, serviceStore, projectStore, jobQueue, "test-secret")

	return handlers, buildStore, deploymentStore, serviceStore, jobQueue
}

func TestCICDHandlers_TriggerBuild(t *testing.T) {
	gin.SetMode(gin.TestMode)

	handlers, buildStore, _, serviceStore, jobQueue := setupCICDHandlers()
	defer jobQueue.Stop()

	// Mock service
	service := &store.Service{
		ID:        1,
		ProjectID: 1,
		Name:      "test-service",
		Image:     "test:latest",
	}
	serviceStore.On("GetService", mock.Anything, int64(1)).Return(service, nil)
	buildStore.On("CreateBuild", mock.Anything, mock.Anything).Return(nil)

	// Setup router
	r := gin.New()
	r.POST("/services/:id/build", handlers.TriggerBuild)

	// Prepare request
	buildSpec := store.BuildSpec{
		GitURL:      "https://github.com/example/repo.git",
		GitRef:      "main",
		ContextPath: ".",
		Dockerfile:  "Dockerfile",
	}
	jsonData, _ := json.Marshal(buildSpec)

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("POST", "/services/1/build", bytes.NewBuffer(jsonData))
	req.Header.Set("Content-Type", "application/json")
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusCreated, w.Code)

	var response map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Equal(t, float64(1), response["build_id"])
	assert.Contains(t, response, "job_id")
	assert.Equal(t, "queued", response["status"])

	serviceStore.AssertExpectations(t)
	buildStore.AssertExpectations(t)
}

func TestCICDHandlers_TriggerBuild_InvalidServiceID(t *testing.T) {
	gin.SetMode(gin.TestMode)

	handlers, _, _, _, jobQueue := setupCICDHandlers()
	defer jobQueue.Stop()

	r := gin.New()
	r.POST("/services/:id/build", handlers.TriggerBuild)

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("POST", "/services/invalid/build", bytes.NewBuffer([]byte("{}")))
	req.Header.Set("Content-Type", "application/json")
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusBadRequest, w.Code)
}

func TestCICDHandlers_GetBuild(t *testing.T) {
	gin.SetMode(gin.TestMode)

	handlers, buildStore, _, _, jobQueue := setupCICDHandlers()
	defer jobQueue.Stop()

	// Mock build
	build := &store.Build{
		ID:        1,
		ProjectID: 1,
		ServiceID: 1,
		GitURL:    "https://github.com/example/repo.git",
		GitRef:    "main",
		ImageTag:  "test:main-123",
		Status:    "success",
	}
	buildStore.On("GetBuild", mock.Anything, int64(1)).Return(build, nil)

	r := gin.New()
	r.GET("/builds/:id", handlers.GetBuild)

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("GET", "/builds/1", nil)
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	var response store.Build
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Equal(t, int64(1), response.ID)
	assert.Equal(t, "success", response.Status)

	buildStore.AssertExpectations(t)
}

func TestCICDHandlers_ListBuilds(t *testing.T) {
	gin.SetMode(gin.TestMode)

	handlers, buildStore, _, _, jobQueue := setupCICDHandlers()
	defer jobQueue.Stop()

	// Mock builds
	builds := []*store.Build{
		{ID: 1, ServiceID: 1, Status: "success"},
		{ID: 2, ServiceID: 1, Status: "failed"},
	}
	buildStore.On("ListBuilds", mock.Anything, int64(1)).Return(builds, nil)

	r := gin.New()
	r.GET("/services/:id/builds", handlers.ListBuilds)

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("GET", "/services/1/builds", nil)
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	var response []*store.Build
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Len(t, response, 2)
	assert.Equal(t, int64(1), response[0].ID)
	assert.Equal(t, int64(2), response[1].ID)

	buildStore.AssertExpectations(t)
}

func TestCICDHandlers_TriggerDeployment(t *testing.T) {
	gin.SetMode(gin.TestMode)

	handlers, _, deploymentStore, serviceStore, jobQueue := setupCICDHandlers()
	defer jobQueue.Stop()

	// Mock service
	service := &store.Service{
		ID:        1,
		ProjectID: 1,
		Name:      "test-service",
	}
	serviceStore.On("GetService", mock.Anything, int64(1)).Return(service, nil)
	deploymentStore.On("CreateDeployment", mock.Anything, mock.Anything).Return(nil)

	r := gin.New()
	r.POST("/services/:id/deploy", handlers.TriggerDeployment)

	deploySpec := store.DeploymentSpec{
		ImageTag: "test:v1.0.0",
		Reason:   "Manual deployment",
	}
	jsonData, _ := json.Marshal(deploySpec)

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("POST", "/services/1/deploy", bytes.NewBuffer(jsonData))
	req.Header.Set("Content-Type", "application/json")
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusCreated, w.Code)

	var response map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Equal(t, float64(1), response["deployment_id"])
	assert.Contains(t, response, "job_id")
	assert.Equal(t, "queued", response["status"])

	serviceStore.AssertExpectations(t)
	deploymentStore.AssertExpectations(t)
}

func TestCICDHandlers_RollbackDeployment(t *testing.T) {
	gin.SetMode(gin.TestMode)

	handlers, _, deploymentStore, serviceStore, jobQueue := setupCICDHandlers()
	defer jobQueue.Stop()

	// Mock service
	service := &store.Service{
		ID:        1,
		ProjectID: 1,
		Name:      "test-service",
	}
	serviceStore.On("GetService", mock.Anything, int64(1)).Return(service, nil)

	// Mock deployment history (current and previous)
	deployments := []*store.Deployment{
		{ID: 2, ServiceID: 1, ImageTag: "test:v2.0.0", Status: "success"}, // Current
		{ID: 1, ServiceID: 1, ImageTag: "test:v1.0.0", Status: "success"}, // Previous
	}
	deploymentStore.On("ListDeployments", mock.Anything, int64(1)).Return(deployments, nil)
	deploymentStore.On("CreateDeployment", mock.Anything, mock.Anything).Return(nil)

	r := gin.New()
	r.POST("/services/:id/rollback", handlers.RollbackDeployment)

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("POST", "/services/1/rollback", nil)
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusCreated, w.Code)

	var response map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Equal(t, float64(1), response["deployment_id"])
	assert.Equal(t, float64(1), response["rollback_to"])
	assert.Equal(t, "test:v1.0.0", response["rollback_image_tag"])
	assert.Equal(t, "queued", response["status"])

	serviceStore.AssertExpectations(t)
	deploymentStore.AssertExpectations(t)
}

func TestCICDHandlers_RollbackDeployment_NoPreviousDeployment(t *testing.T) {
	gin.SetMode(gin.TestMode)

	handlers, _, deploymentStore, _, jobQueue := setupCICDHandlers()
	defer jobQueue.Stop()

	// Mock only one deployment (no previous to rollback to)
	deployments := []*store.Deployment{
		{ID: 1, ServiceID: 1, ImageTag: "test:v1.0.0", Status: "success"},
	}
	deploymentStore.On("ListDeployments", mock.Anything, int64(1)).Return(deployments, nil)

	r := gin.New()
	r.POST("/services/:id/rollback", handlers.RollbackDeployment)

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("POST", "/services/1/rollback", nil)
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusBadRequest, w.Code)

	deploymentStore.AssertExpectations(t)
}

func TestCICDHandlers_GitHubWebhook_ValidSignature(t *testing.T) {
	gin.SetMode(gin.TestMode)

	handlers, _, _, _, jobQueue := setupCICDHandlers()
	defer jobQueue.Stop()

	r := gin.New()
	r.POST("/webhooks/github", handlers.GitHubWebhook)

	// Create webhook payload
	payload := GitHubPushPayload{
		Ref:   "refs/heads/main",
		After: "abc123def456",
		Repository: struct {
			ID       int    `json:"id"`
			Name     string `json:"name"`
			FullName string `json:"full_name"`
			CloneURL string `json:"clone_url"`
			GitURL   string `json:"git_url"`
			SSHURL   string `json:"ssh_url"`
		}{
			ID:       123,
			Name:     "test-repo",
			FullName: "example/test-repo",
			CloneURL: "https://github.com/example/test-repo.git",
		},
	}

	jsonData, _ := json.Marshal(payload)

	// Create HMAC signature
	mac := hmac.New(sha256.New, []byte("test-secret"))
	mac.Write(jsonData)
	signature := "sha256=" + hex.EncodeToString(mac.Sum(nil))

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("POST", "/webhooks/github", bytes.NewBuffer(jsonData))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-GitHub-Event", "push")
	req.Header.Set("X-Hub-Signature-256", signature)
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	var response map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)

	// Since no services match the repository, should get a message about no services
	assert.Contains(t, response["message"], "no services configured")
}

func TestCICDHandlers_GitHubWebhook_InvalidSignature(t *testing.T) {
	gin.SetMode(gin.TestMode)

	handlers, _, _, _, jobQueue := setupCICDHandlers()
	defer jobQueue.Stop()

	r := gin.New()
	r.POST("/webhooks/github", handlers.GitHubWebhook)

	payload := `{"ref": "refs/heads/main"}`

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("POST", "/webhooks/github", bytes.NewBufferString(payload))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-GitHub-Event", "push")
	req.Header.Set("X-Hub-Signature-256", "sha256=invalid")
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusUnauthorized, w.Code)
}

func TestCICDHandlers_GitHubWebhook_IgnoredEvent(t *testing.T) {
	gin.SetMode(gin.TestMode)

	handlers, _, _, _, jobQueue := setupCICDHandlers()
	defer jobQueue.Stop()

	r := gin.New()
	r.POST("/webhooks/github", handlers.GitHubWebhook)

	payload := `{"ref": "refs/heads/main"}`

	// Create valid signature
	mac := hmac.New(sha256.New, []byte("test-secret"))
	mac.Write([]byte(payload))
	signature := "sha256=" + hex.EncodeToString(mac.Sum(nil))

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("POST", "/webhooks/github", bytes.NewBufferString(payload))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-GitHub-Event", "ping") // Not a push event
	req.Header.Set("X-Hub-Signature-256", signature)
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	var response map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Equal(t, "event ignored", response["message"])
}

func TestCICDHandlers_GetJob(t *testing.T) {
	gin.SetMode(gin.TestMode)

	handlers, _, _, _, jobQueue := setupCICDHandlers()
	defer jobQueue.Stop()

	// Enqueue a test job
	job := jobQueue.Enqueue(jobs.JobTypeBuild, map[string]interface{}{
		"test": "data",
	})

	r := gin.New()
	r.GET("/jobs/:id", handlers.GetJob)

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("GET", "/jobs/"+job.ID, nil)
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	var response jobs.Job
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Equal(t, job.ID, response.ID)
	assert.Equal(t, jobs.JobTypeBuild, response.Type)
	assert.Equal(t, jobs.JobStatusQueued, response.Status)
}

func TestCICDHandlers_GetJob_NotFound(t *testing.T) {
	gin.SetMode(gin.TestMode)

	handlers, _, _, _, jobQueue := setupCICDHandlers()
	defer jobQueue.Stop()

	r := gin.New()
	r.GET("/jobs/:id", handlers.GetJob)

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("GET", "/jobs/nonexistent", nil)
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusNotFound, w.Code)
}

func TestVerifyWebhookSignature(t *testing.T) {
	payload := []byte(`{"test": "data"}`)
	secret := "my-secret"

	mac := hmac.New(sha256.New, []byte(secret))
	mac.Write(payload)
	validSignature := "sha256=" + hex.EncodeToString(mac.Sum(nil))

	// Valid signature
	assert.True(t, verifyWebhookSignature(payload, validSignature, secret))

	// Invalid signature
	assert.False(t, verifyWebhookSignature(payload, "sha256=invalid", secret))

	// Wrong format
	assert.False(t, verifyWebhookSignature(payload, "invalid-format", secret))

	// Different payload
	assert.False(t, verifyWebhookSignature([]byte("different"), validSignature, secret))

	// Different secret
	assert.False(t, verifyWebhookSignature(payload, validSignature, "different-secret"))
}
