package api

import (
	"bytes"
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strconv"
	"testing"
	"time"

	"github.com/GLINCKER/glinrdock/internal/audit"
	"github.com/GLINCKER/glinrdock/internal/auth"
	"github.com/GLINCKER/glinrdock/internal/config"
	"github.com/GLINCKER/glinrdock/internal/dockerx"
	"github.com/GLINCKER/glinrdock/internal/plan"
	"github.com/GLINCKER/glinrdock/internal/store"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// MockAuditStore implements audit.Store for testing
type MockAuditStore struct {
	entries []audit.Entry
}

func (m *MockAuditStore) CreateAuditEntry(ctx context.Context, entry *audit.Entry) error {
	// Simulate database by adding ID and storing entry
	entry.ID = int64(len(m.entries) + 1)
	m.entries = append(m.entries, *entry)
	return nil
}

func (m *MockAuditStore) GetAuditEntries(ctx context.Context, limit int) ([]audit.Entry, error) {
	if limit <= 0 || limit > len(m.entries) {
		return m.entries, nil
	}
	return m.entries[:limit], nil
}

func (m *MockAuditStore) GetEntriesCount() int {
	return len(m.entries)
}

func (m *MockAuditStore) GetLastEntry() *audit.Entry {
	if len(m.entries) == 0 {
		return nil
	}
	return &m.entries[len(m.entries)-1]
}

func (m *MockAuditStore) ClearEntries() {
	m.entries = []audit.Entry{}
}

func setupAuditTestServer(t *testing.T) (*gin.Engine, *MockAuditStore, *Handlers) {
	gin.SetMode(gin.TestMode)

	// Create mock stores
	mockStore := &store.Store{}
	mockAuditStore := &MockAuditStore{}
	mockDockerClient := &dockerx.MockClient{}
	mockEngine := &dockerx.MockEngine{}

	// Create audit logger with mock store
	auditLogger := audit.New(mockAuditStore)

	// Create plan enforcer (use premium to avoid quota issues in tests)
	planEnforcer := plan.New(&config.PlanConfig{
		Plan:   config.PlanPremium,
		Limits: config.PlanLimits{MaxTokens: -1, MaxClients: -1, MaxUsers: -1},
	})

	// Create handlers with audit logger
	handlers := NewHandlers(
		mockDockerClient,
		mockStore,
		mockStore,
		mockStore,
		mockStore,
		mockEngine,
		nil,    // nginxConfig
		nil,    // cicdHandlers
		nil,    // certHandlers
		nil,    // metricsHandlers
		planEnforcer,
		nil,    // licenseManager
		auditLogger,
		&config.PlanConfig{Plan: config.PlanPremium},
	)

	// Setup auth service
	authService := auth.NewAuthService(mockStore)

	// Setup router
	r := gin.New()
	SetupRoutes(r, handlers, []string{}, authService, nil, planEnforcer)

	return r, mockAuditStore, handlers
}

func createAuthToken(t *testing.T) string {
	// Create a test token - in real tests this would be generated by the store
	return "test-admin-token-12345"
}

func TestAuditTokenOperations(t *testing.T) {
	r, auditStore, _ := setupAuditTestServer(t)

	// Test token creation produces audit entry
	t.Run("token create produces audit entry", func(t *testing.T) {
		auditStore.ClearEntries()
		
		// Create token request
		tokenReq := CreateTokenRequest{
			Name:  "test-token",
			Plain: "test-plain-token",
			Role:  store.RoleAdmin,
		}
		reqBody, _ := json.Marshal(tokenReq)

		req, _ := http.NewRequest("POST", "/v1/tokens", bytes.NewBuffer(reqBody))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Authorization", "Bearer "+createAuthToken(t))

		w := httptest.NewRecorder()
		r.ServeHTTP(w, req)

		// The request might fail due to mock store limitations, but audit should still be recorded
		// Check if audit entry was created
		assert.Greater(t, auditStore.GetEntriesCount(), 0, "Audit entry should be created for token creation")

		if auditStore.GetEntriesCount() > 0 {
			lastEntry := auditStore.GetLastEntry()
			assert.Equal(t, audit.ActionTokenCreate, lastEntry.Action, "Audit action should be token_create")
			assert.Equal(t, "token", lastEntry.TargetType, "Target type should be token")
			assert.Equal(t, tokenReq.Name, lastEntry.TargetID, "Target ID should be token name")
		}
	})

	// Test token deletion produces audit entry
	t.Run("token delete produces audit entry", func(t *testing.T) {
		auditStore.ClearEntries()

		req, _ := http.NewRequest("DELETE", "/v1/tokens/test-token", nil)
		req.Header.Set("Authorization", "Bearer "+createAuthToken(t))

		w := httptest.NewRecorder()
		r.ServeHTTP(w, req)

		// Check if audit entry was created
		assert.Greater(t, auditStore.GetEntriesCount(), 0, "Audit entry should be created for token deletion")

		if auditStore.GetEntriesCount() > 0 {
			lastEntry := auditStore.GetLastEntry()
			assert.Equal(t, audit.ActionTokenDelete, lastEntry.Action, "Audit action should be token_delete")
			assert.Equal(t, "token", lastEntry.TargetType, "Target type should be token")
			assert.Equal(t, "test-token", lastEntry.TargetID, "Target ID should be token name")
		}
	})
}

func TestAuditSystemOperations(t *testing.T) {
	r, auditStore, _ := setupAuditTestServer(t)

	// Test system lockdown produces audit entry
	t.Run("system lockdown produces audit entry", func(t *testing.T) {
		auditStore.ClearEntries()

		lockdownReq := SystemLockdownRequest{
			Reason: "Security maintenance",
		}
		reqBody, _ := json.Marshal(lockdownReq)

		req, _ := http.NewRequest("POST", "/v1/system/lockdown", bytes.NewBuffer(reqBody))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Authorization", "Bearer "+createAuthToken(t))

		w := httptest.NewRecorder()
		r.ServeHTTP(w, req)

		// Check if audit entry was created
		assert.Greater(t, auditStore.GetEntriesCount(), 0, "Audit entry should be created for system lockdown")

		if auditStore.GetEntriesCount() > 0 {
			lastEntry := auditStore.GetLastEntry()
			assert.Equal(t, audit.ActionSystemLockdown, lastEntry.Action, "Audit action should be system_lockdown")
			assert.Equal(t, "system", lastEntry.TargetType, "Target type should be system")
			
			// Check metadata contains reason
			reason, exists := lastEntry.Meta["reason"]
			assert.True(t, exists, "Audit metadata should contain reason")
			assert.Equal(t, lockdownReq.Reason, reason, "Audit reason should match request")
		}
	})

	// Test emergency restart produces audit entry
	t.Run("emergency restart produces audit entry", func(t *testing.T) {
		auditStore.ClearEntries()

		req, _ := http.NewRequest("POST", "/v1/system/emergency-restart", nil)
		req.Header.Set("Authorization", "Bearer "+createAuthToken(t))

		w := httptest.NewRecorder()
		r.ServeHTTP(w, req)

		// Check if audit entry was created
		assert.Greater(t, auditStore.GetEntriesCount(), 0, "Audit entry should be created for emergency restart")

		if auditStore.GetEntriesCount() > 0 {
			lastEntry := auditStore.GetLastEntry()
			assert.Equal(t, audit.ActionSystemRestart, lastEntry.Action, "Audit action should be system_restart")
			assert.Equal(t, "system", lastEntry.TargetType, "Target type should be system")
			
			// Check metadata contains restart info
			restartReason, exists := lastEntry.Meta["restart_reason"]
			assert.True(t, exists, "Audit metadata should contain restart_reason")
			assert.Equal(t, "emergency_restart", restartReason, "Restart reason should be emergency_restart")
		}
	})
}

func TestAuditServiceOperations(t *testing.T) {
	r, auditStore, _ := setupAuditTestServer(t)

	serviceID := "123"

	// Test service start produces audit entry
	t.Run("service start produces audit entry", func(t *testing.T) {
		auditStore.ClearEntries()

		req, _ := http.NewRequest("POST", "/v1/services/"+serviceID+"/start", nil)
		req.Header.Set("Authorization", "Bearer "+createAuthToken(t))

		w := httptest.NewRecorder()
		r.ServeHTTP(w, req)

		// The request will likely fail due to mock limitations, but audit should be recorded if handler runs
		// Note: Some audit entries might not be created if the handler fails early due to service not found
		// This is expected behavior - audit is recorded when the actual operation is attempted
		
		if auditStore.GetEntriesCount() > 0 {
			lastEntry := auditStore.GetLastEntry()
			assert.Equal(t, audit.ActionServiceStart, lastEntry.Action, "Audit action should be service_start")
			assert.Equal(t, "service", lastEntry.TargetType, "Target type should be service")
			assert.Equal(t, serviceID, lastEntry.TargetID, "Target ID should be service ID")
		}
	})

	// Test service stop produces audit entry
	t.Run("service stop produces audit entry", func(t *testing.T) {
		auditStore.ClearEntries()

		req, _ := http.NewRequest("POST", "/v1/services/"+serviceID+"/stop", nil)
		req.Header.Set("Authorization", "Bearer "+createAuthToken(t))

		w := httptest.NewRecorder()
		r.ServeHTTP(w, req)

		if auditStore.GetEntriesCount() > 0 {
			lastEntry := auditStore.GetLastEntry()
			assert.Equal(t, audit.ActionServiceStop, lastEntry.Action, "Audit action should be service_stop")
			assert.Equal(t, "service", lastEntry.TargetType, "Target type should be service")
			assert.Equal(t, serviceID, lastEntry.TargetID, "Target ID should be service ID")
		}
	})

	// Test service restart produces audit entry
	t.Run("service restart produces audit entry", func(t *testing.T) {
		auditStore.ClearEntries()

		req, _ := http.NewRequest("POST", "/v1/services/"+serviceID+"/restart", nil)
		req.Header.Set("Authorization", "Bearer "+createAuthToken(t))

		w := httptest.NewRecorder()
		r.ServeHTTP(w, req)

		if auditStore.GetEntriesCount() > 0 {
			lastEntry := auditStore.GetLastEntry()
			assert.Equal(t, audit.ActionServiceRestart, lastEntry.Action, "Audit action should be service_restart")
			assert.Equal(t, "service", lastEntry.TargetType, "Target type should be service")
			assert.Equal(t, serviceID, lastEntry.TargetID, "Target ID should be service ID")
		}
	})
}

func TestAuditDeploymentOperations(t *testing.T) {
	r, auditStore, _ := setupAuditTestServer(t)

	serviceID := "123"

	// Test service deployment produces audit entry
	t.Run("service deploy produces audit entry", func(t *testing.T) {
		auditStore.ClearEntries()

		req, _ := http.NewRequest("POST", "/v1/cicd/services/"+serviceID+"/deploy", nil)
		req.Header.Set("Authorization", "Bearer "+createAuthToken(t))

		w := httptest.NewRecorder()
		r.ServeHTTP(w, req)

		// This will likely fail due to missing CICD handlers in test setup,
		// but the audit entry should be recorded by the wrapper
		if auditStore.GetEntriesCount() > 0 {
			lastEntry := auditStore.GetLastEntry()
			assert.Equal(t, audit.ActionServiceDeploy, lastEntry.Action, "Audit action should be service_deploy")
			assert.Equal(t, "service", lastEntry.TargetType, "Target type should be service")
			assert.Equal(t, serviceID, lastEntry.TargetID, "Target ID should be service ID")
		}
	})
}

func TestAuditEntryStructure(t *testing.T) {
	// Test audit entry structure and required fields
	auditStore := &MockAuditStore{}
	auditLogger := audit.New(auditStore)

	actor := "test-user"
	action := audit.ActionTokenCreate
	targetType := "token"
	targetID := "test-token"
	meta := map[string]interface{}{
		"role":       "admin",
		"created_by": "admin",
	}

	// Record audit entry
	auditLogger.Record(context.Background(), actor, action, targetType, targetID, meta)

	require.Equal(t, 1, auditStore.GetEntriesCount(), "Should have one audit entry")

	entry := auditStore.GetLastEntry()
	assert.NotZero(t, entry.ID, "Entry should have ID")
	assert.False(t, entry.Timestamp.IsZero(), "Entry should have timestamp")
	assert.Equal(t, actor, entry.Actor, "Entry should have correct actor")
	assert.Equal(t, action, entry.Action, "Entry should have correct action")
	assert.Equal(t, targetType, entry.TargetType, "Entry should have correct target type")
	assert.Equal(t, targetID, entry.TargetID, "Entry should have correct target ID")
	assert.Equal(t, meta, entry.Meta, "Entry should have correct metadata")

	// Verify timestamp is recent
	assert.WithinDuration(t, time.Now(), entry.Timestamp, time.Minute, "Timestamp should be recent")
}

func TestAuditMetadataContent(t *testing.T) {
	auditStore := &MockAuditStore{}
	auditLogger := audit.New(auditStore)

	// Test token action metadata
	t.Run("token action metadata", func(t *testing.T) {
		auditStore.ClearEntries()
		
		tokenName := "test-token"
		meta := map[string]interface{}{
			"role":       "deployer",
			"created_by": "admin",
			"token_id":   int64(123),
		}

		auditLogger.RecordTokenAction(context.Background(), "admin", audit.ActionTokenCreate, tokenName, meta)

		entry := auditStore.GetLastEntry()
		require.NotNil(t, entry, "Should have audit entry")
		
		assert.Equal(t, tokenName, entry.Meta["token_name"], "Should include token name in metadata")
		assert.Equal(t, "deployer", entry.Meta["role"], "Should include role in metadata")
		assert.Equal(t, "admin", entry.Meta["created_by"], "Should include creator in metadata")
		assert.Equal(t, int64(123), entry.Meta["token_id"], "Should include token ID in metadata")
	})

	// Test service action metadata
	t.Run("service action metadata", func(t *testing.T) {
		auditStore.ClearEntries()
		
		serviceID := "456"
		meta := map[string]interface{}{
			"service_name":   "web-app",
			"project_id":     int64(789),
			"container_name": "glinr_789_web-app",
			"started_by":     "deployer",
		}

		auditLogger.RecordServiceAction(context.Background(), "deployer", audit.ActionServiceStart, serviceID, meta)

		entry := auditStore.GetLastEntry()
		require.NotNil(t, entry, "Should have audit entry")
		
		assert.Equal(t, "web-app", entry.Meta["service_name"], "Should include service name in metadata")
		assert.Equal(t, int64(789), entry.Meta["project_id"], "Should include project ID in metadata")
		assert.Equal(t, "glinr_789_web-app", entry.Meta["container_name"], "Should include container name in metadata")
		assert.Equal(t, "deployer", entry.Meta["started_by"], "Should include actor role in metadata")
	})

	// Test system action metadata
	t.Run("system action metadata", func(t *testing.T) {
		auditStore.ClearEntries()
		
		meta := map[string]interface{}{
			"reason":         "Security update",
			"initiated_by":   "admin-user",
			"restart_reason": "emergency_restart",
		}

		auditLogger.RecordSystemAction(context.Background(), "admin", audit.ActionSystemRestart, meta)

		entry := auditStore.GetLastEntry()
		require.NotNil(t, entry, "Should have audit entry")
		
		assert.Equal(t, "Security update", entry.Meta["reason"], "Should include reason in metadata")
		assert.Equal(t, "admin-user", entry.Meta["initiated_by"], "Should include initiator in metadata")
		assert.Equal(t, "emergency_restart", entry.Meta["restart_reason"], "Should include restart reason in metadata")
	})
}

func TestAuditActorExtraction(t *testing.T) {
	tests := []struct {
		name         string
		contextValue string
		contextKey   string
		expected     string
		description  string
	}{
		{
			name:         "token name in context",
			contextValue: "admin-token",
			contextKey:   "token_name",
			expected:     "token:admin-token",
			description:  "Should extract token name from context",
		},
		{
			name:         "user ID in context",
			contextValue: "user123",
			contextKey:   "user_id",
			expected:     "user:user123",
			description:  "Should extract user ID from context",
		},
		{
			name:        "no context values",
			expected:    "system",
			description: "Should default to system when no context",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			if tt.contextKey != "" {
				ctx = context.WithValue(ctx, tt.contextKey, tt.contextValue)
			}

			actor := audit.GetActorFromContext(ctx)
			assert.Equal(t, tt.expected, actor, tt.description)
		})
	}
}

func BenchmarkAuditLogging(b *testing.B) {
	auditStore := &MockAuditStore{}
	auditLogger := audit.New(auditStore)

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		i := 0
		for pb.Next() {
			auditLogger.RecordTokenAction(
				context.Background(),
				"user"+strconv.Itoa(i),
				audit.ActionTokenCreate,
				"token"+strconv.Itoa(i),
				map[string]interface{}{
					"role": "admin",
					"id":   i,
				},
			)
			i++
		}
	})
}