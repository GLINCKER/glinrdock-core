package proxy

import (
	"bytes"
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"text/template"
	"time"

	"github.com/GLINCKER/glinrdock/internal/store"
	"github.com/rs/zerolog/log"
)

// NginxConfig represents the nginx configuration generator
type NginxConfig struct {
	ConfigPath     string
	TempPath       string
	BackupPath     string
	ReloadCmd      []string
	ValidateCmd    []string
	DataDir        string // For cert path resolution
	store          RouteStore
	lastConfigHash string // Hash of the last applied configuration
}

// RouteStore interface for accessing routes and services
type RouteStore interface {
	GetAllRoutes(ctx context.Context) ([]store.Route, error)
	GetService(ctx context.Context, id int64) (store.Service, error)
	GetDomain(ctx context.Context, id int64) (store.Domain, error)
}

// RouteData represents data needed for nginx config generation
type RouteData struct {
	Route           store.Route
	Service         store.Service
	Domain          *store.Domain // nil if no domain_id
	UpstreamName    string
	ServiceEndpoint string
	IsFullProxy     bool // true if should generate full proxy, false if only challenge
}

// ConfigData represents the full nginx configuration data
type ConfigData struct {
	Routes    []RouteData
	Generated time.Time
}

// NewNginxConfig creates a new nginx configuration generator
func NewNginxConfig(configPath, dataDir string, routeStore RouteStore) *NginxConfig {
	return &NginxConfig{
		ConfigPath:  configPath,
		TempPath:    configPath + ".tmp",
		BackupPath:  configPath + ".backup",
		ReloadCmd:   []string{"nginx", "-s", "reload"},
		ValidateCmd: []string{"nginx", "-t"},
		DataDir:     dataDir,
		store:       routeStore,
	}
}

// nginxTemplate is the main nginx configuration template
const nginxTemplate = `# Generated by glinrdock at {{.Generated.Format "2006-01-02 15:04:05 UTC"}}
# DO NOT EDIT MANUALLY - Changes will be overwritten

events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # Basic settings
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Logging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                   '$status $body_bytes_sent "$http_referer" '
                   '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log warn;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1000;
    gzip_proxied any;
    gzip_types text/plain text/css text/xml text/javascript
               application/json application/javascript application/xml+rss;

{{range .Routes}}
{{if .IsFullProxy}}
    # Upstream for {{.Route.Domain}} -> {{.Service.Name}}
    upstream {{.UpstreamName}} {
        server {{.ServiceEndpoint}};
        keepalive 32;
    }
{{end}}
{{end}}

{{range .Routes}}
    # Server block for {{.Route.Domain}}{{if .Domain}} (Domain: {{.Domain.Name}}, Status: {{.Domain.Status}}){{end}}
    server {
        server_name {{.Route.Domain}};
        
{{if .IsFullProxy}}
{{if .Route.TLS}}
        listen 443 ssl http2;
        
        # TLS Configuration (certificates should be managed externally)
        ssl_certificate /etc/nginx/ssl/{{.Route.Domain}}.crt;
        ssl_certificate_key /etc/nginx/ssl/{{.Route.Domain}}.key;
        
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256;
        ssl_prefer_server_ciphers on;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;
        
        # Security headers
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
        add_header X-Content-Type-Options nosniff always;
        add_header X-Frame-Options DENY always;
        add_header X-XSS-Protection "1; mode=block" always;
{{else}}
        listen 80;
{{end}}

        # Health check endpoint
        location /health {
            access_log off;
            return 200 "OK\n";
            add_header Content-Type text/plain;
        }

        # Proxy to service
        location / {
            proxy_pass http://{{.UpstreamName}};
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
            
            # Buffer settings
            proxy_buffering on;
            proxy_buffer_size 4k;
            proxy_buffers 8 4k;
            proxy_busy_buffers_size 8k;
        }
    }

{{if .Route.TLS}}
    # HTTP to HTTPS redirect for {{.Route.Domain}}
    server {
        listen 80;
        server_name {{.Route.Domain}};
        return 301 https://$server_name$request_uri;
    }
{{end}}
{{else}}
        # Challenge-only server for domain verification ({{if .Domain}}{{.Domain.Status}}{{end}})
        listen 80;
        
        # ACME challenge location for Let's Encrypt HTTP-01
        location /.well-known/acme-challenge/ {
            root /var/www/acme-challenge;
            try_files $uri =404;
        }
        
        # Block all other requests during domain verification
        location / {
            return 404;
        }
    }
{{end}}
{{end}}

    # Default server (catch-all)
    server {
        listen 80 default_server;
        listen 443 ssl default_server;
        server_name _;
        
        # Default SSL certificate (self-signed fallback)
        ssl_certificate /etc/nginx/ssl/default.crt;
        ssl_certificate_key /etc/nginx/ssl/default.key;
        
        return 444; # Close connection without response
    }
}
`

// GenerateConfig generates the complete nginx configuration
func (nc *NginxConfig) GenerateConfig(ctx context.Context) error {
	log.Info().Msg("generating nginx configuration")

	// Get all routes from database
	routes, err := nc.store.GetAllRoutes(ctx)
	if err != nil {
		return fmt.Errorf("failed to get routes: %w", err)
	}

	// Build route data with service information
	var routeData []RouteData
	for _, route := range routes {
		service, err := nc.store.GetService(ctx, route.ServiceID)
		if err != nil {
			log.Warn().Err(err).Int64("service_id", route.ServiceID).Msg("skipping route for missing service")
			continue
		}

		rd := RouteData{
			Route:           route,
			Service:         service,
			UpstreamName:    fmt.Sprintf("glinr_%d_%s", service.ProjectID, service.Name),
			ServiceEndpoint: fmt.Sprintf("host.docker.internal:%d", route.Port),
			IsFullProxy:     true, // default to full proxy
		}

		// Check if route has domain_id
		if route.DomainID != nil {
			domain, err := nc.store.GetDomain(ctx, *route.DomainID)
			if err != nil {
				log.Warn().Err(err).Int64("domain_id", *route.DomainID).Msg("skipping route for missing domain")
				continue
			}

			rd.Domain = &domain

			// Determine if we should create full proxy or just challenge
			switch domain.Status {
			case "active":
				rd.IsFullProxy = true
			case "pending", "verified":
				// Only mount challenge location for HTTP-01
				rd.IsFullProxy = false
			default:
				// Skip routes for domains with error status or other statuses
				log.Debug().Str("domain_status", domain.Status).Str("domain", domain.Name).Msg("skipping route for non-ready domain")
				continue
			}
		}

		routeData = append(routeData, rd)
	}

	// Prepare template data
	configData := ConfigData{
		Routes:    routeData,
		Generated: time.Now().UTC(),
	}

	// Parse and execute template
	tmpl, err := template.New("nginx").Parse(nginxTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse nginx template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, configData); err != nil {
		return fmt.Errorf("failed to execute nginx template: %w", err)
	}

	// Write to temporary file first (atomic write)
	if err := os.WriteFile(nc.TempPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write temporary config: %w", err)
	}

	log.Info().
		Str("config_path", nc.ConfigPath).
		Int("routes", len(routeData)).
		Msg("nginx configuration generated")

	return nil
}

// ValidateConfig validates the nginx configuration using nginx -t
func (nc *NginxConfig) ValidateConfig() error {
	log.Debug().Strs("cmd", nc.ValidateCmd).Msg("validating nginx configuration")

	cmd := exec.Command(nc.ValidateCmd[0], nc.ValidateCmd[1:]...)
	output, err := cmd.CombinedOutput()

	if err != nil {
		log.Error().
			Err(err).
			Str("output", string(output)).
			Msg("nginx configuration validation failed")
		return fmt.Errorf("nginx validation failed: %w\nOutput: %s", err, output)
	}

	log.Debug().Msg("nginx configuration validation passed")
	return nil
}

// AtomicSwap atomically replaces the main config file with the validated temp file
func (nc *NginxConfig) AtomicSwap() error {
	// Ensure parent directory exists
	configDir := filepath.Dir(nc.ConfigPath)
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Atomic rename (temp -> main)
	if err := os.Rename(nc.TempPath, nc.ConfigPath); err != nil {
		return fmt.Errorf("failed to swap config files: %w", err)
	}

	log.Info().Str("config_path", nc.ConfigPath).Msg("nginx configuration updated")
	return nil
}

// ReloadNginx triggers nginx to reload the configuration
func (nc *NginxConfig) ReloadNginx() error {
	log.Info().Strs("cmd", nc.ReloadCmd).Msg("reloading nginx")

	cmd := exec.Command(nc.ReloadCmd[0], nc.ReloadCmd[1:]...)
	output, err := cmd.CombinedOutput()

	if err != nil {
		log.Error().
			Err(err).
			Str("output", string(output)).
			Msg("nginx reload failed")
		return fmt.Errorf("nginx reload failed: %w\nOutput: %s", err, output)
	}

	log.Info().Msg("nginx reloaded successfully")
	return nil
}

// UpdateAndReload performs the complete update cycle: generate -> validate -> swap -> reload
func (nc *NginxConfig) UpdateAndReload(ctx context.Context) error {
	startTime := time.Now()
	log.Info().Msg("updating nginx configuration")

	// Step 1: Calculate config hash to check if update is needed
	_, configHash, err := nc.calculateConfigHash(ctx)
	if err != nil {
		return fmt.Errorf("failed to calculate config hash: %w", err)
	}

	// Step 2: Compare with last applied hash
	if nc.lastConfigHash == configHash {
		log.Info().
			Str("config_hash", configHash).
			Msg("nginx configuration unchanged, skipping reload")
		return nil
	}

	log.Info().
		Str("old_hash", nc.lastConfigHash).
		Str("new_hash", configHash).
		Msg("nginx configuration changed, proceeding with reload")

	// Step 3: Generate configuration
	if err := nc.GenerateConfig(ctx); err != nil {
		return fmt.Errorf("failed to generate config: %w", err)
	}

	// Step 4: Validate configuration (using temp file)
	// Temporarily swap to validate against the temp config
	originalValidateCmd := nc.ValidateCmd
	if len(nc.ValidateCmd) >= 2 && nc.ValidateCmd[1] == "-t" {
		nc.ValidateCmd = append(nc.ValidateCmd, "-c", nc.TempPath)
	}

	err = nc.ValidateConfig()
	nc.ValidateCmd = originalValidateCmd // Restore original command

	if err != nil {
		// Clean up temp file on validation failure
		os.Remove(nc.TempPath)
		return fmt.Errorf("config validation failed: %w", err)
	}

	// Step 5: Atomic swap
	if err := nc.AtomicSwap(); err != nil {
		return fmt.Errorf("failed to swap config: %w", err)
	}

	// Step 6: Reload nginx
	if err := nc.ReloadNginx(); err != nil {
		return fmt.Errorf("failed to reload nginx: %w", err)
	}

	// Step 7: Update the last applied hash
	nc.lastConfigHash = configHash

	updateDuration := time.Since(startTime)

	if updateDuration > 300*time.Millisecond {
		log.Warn().
			Str("config_hash", configHash).
			Dur("update_duration", updateDuration).
			Msg("nginx configuration update took longer than 300ms")
	} else {
		log.Info().
			Str("config_hash", configHash).
			Dur("update_duration", updateDuration).
			Msg("nginx configuration updated and reloaded successfully")
	}

	return nil
}

// calculateConfigHash computes SHA256 hash of the generated config content
func (nc *NginxConfig) calculateConfigHash(ctx context.Context) (string, string, error) {
	// Get all routes from database
	routes, err := nc.store.GetAllRoutes(ctx)
	if err != nil {
		return "", "", fmt.Errorf("failed to get routes: %w", err)
	}

	// Build route data with service information
	var routeData []RouteData
	for _, route := range routes {
		service, err := nc.store.GetService(ctx, route.ServiceID)
		if err != nil {
			log.Warn().Err(err).Int64("service_id", route.ServiceID).Msg("skipping route for missing service")
			continue
		}

		rd := RouteData{
			Route:           route,
			Service:         service,
			UpstreamName:    fmt.Sprintf("glinr_%d_%s", service.ProjectID, service.Name),
			ServiceEndpoint: fmt.Sprintf("host.docker.internal:%d", route.Port),
		}
		routeData = append(routeData, rd)
	}

	// Prepare template data (use fixed time for consistent hashing)
	configData := ConfigData{
		Routes:    routeData,
		Generated: time.Time{}, // Zero time for consistent hash calculation
	}

	// Parse and execute template
	tmpl, err := template.New("nginx").Parse(nginxTemplate)
	if err != nil {
		return "", "", fmt.Errorf("failed to parse nginx template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, configData); err != nil {
		return "", "", fmt.Errorf("failed to execute nginx template: %w", err)
	}

	configContent := buf.String()

	// Calculate hash
	hasher := sha256.New()
	hasher.Write([]byte(configContent))
	hash := hex.EncodeToString(hasher.Sum(nil))

	return configContent, hash, nil
}

// CleanupTempFile removes the temporary configuration file
func (nc *NginxConfig) CleanupTempFile() error {
	if err := os.Remove(nc.TempPath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to cleanup temp file: %w", err)
	}
	return nil
}

// GetCertPaths returns the certificate and private key paths for a domain
func (nc *NginxConfig) GetCertPaths(domain string) (certPath, keyPath string) {
	certDir := filepath.Join(nc.DataDir, "certs", domain)
	certPath = filepath.Join(certDir, "fullchain.pem")
	keyPath = filepath.Join(certDir, "privkey.pem")
	return
}

// GetChallengeDir returns the directory for ACME challenges
func (nc *NginxConfig) GetChallengeDir() string {
	return filepath.Join(nc.DataDir, "certs", "challenges")
}

// Reload performs a safe nginx reload with backup and rollback on failure
func (nc *NginxConfig) Reload() error {
	log.Info().Msg("starting safe nginx reload")

	// Create backup of current config before reload
	if err := nc.backupCurrentConfig(); err != nil {
		log.Warn().Err(err).Msg("failed to backup current config, proceeding anyway")
	}

	// Log nginx master process info before reload
	if err := nc.logNginxProcessInfo(); err != nil {
		log.Warn().Err(err).Msg("failed to log nginx process info")
	}

	// Validate configuration before reload
	if err := nc.ValidateConfig(); err != nil {
		return fmt.Errorf("configuration validation failed: %w", err)
	}

	// Perform the reload
	if err := nc.ReloadNginx(); err != nil {
		// Attempt to restore backup on reload failure
		if restoreErr := nc.restoreBackupConfig(); restoreErr != nil {
			log.Error().
				Err(restoreErr).
				Msg("failed to restore backup config after reload failure")
			return fmt.Errorf("reload failed and backup restoration failed: %w, restore error: %v", err, restoreErr)
		}
		log.Info().Msg("backup config restored after reload failure")
		return fmt.Errorf("nginx reload failed (backup restored): %w", err)
	}

	log.Info().Msg("nginx reload completed successfully")
	return nil
}

// backupCurrentConfig creates a backup of the current nginx configuration
func (nc *NginxConfig) backupCurrentConfig() error {
	if _, err := os.Stat(nc.ConfigPath); os.IsNotExist(err) {
		// No existing config to backup
		return nil
	}

	// Read current config
	data, err := os.ReadFile(nc.ConfigPath)
	if err != nil {
		return fmt.Errorf("failed to read current config: %w", err)
	}

	// Write backup
	if err := os.WriteFile(nc.BackupPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write backup config: %w", err)
	}

	log.Debug().
		Str("backup_path", nc.BackupPath).
		Msg("nginx config backed up")
	return nil
}

// restoreBackupConfig restores the backup configuration
func (nc *NginxConfig) restoreBackupConfig() error {
	if _, err := os.Stat(nc.BackupPath); os.IsNotExist(err) {
		return fmt.Errorf("backup config not found: %s", nc.BackupPath)
	}

	// Read backup
	data, err := os.ReadFile(nc.BackupPath)
	if err != nil {
		return fmt.Errorf("failed to read backup config: %w", err)
	}

	// Restore config
	if err := os.WriteFile(nc.ConfigPath, data, 0644); err != nil {
		return fmt.Errorf("failed to restore config: %w", err)
	}

	log.Info().
		Str("config_path", nc.ConfigPath).
		Msg("nginx config restored from backup")
	return nil
}

// logNginxProcessInfo logs information about the current nginx master process
func (nc *NginxConfig) logNginxProcessInfo() error {
	// Get nginx master process info
	cmd := exec.Command("pgrep", "-f", "nginx: master process")
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("failed to get nginx master PID: %w", err)
	}

	if len(output) > 0 {
		pid := string(bytes.TrimSpace(output))

		// Get process start time (best effort)
		psCmd := exec.Command("ps", "-p", pid, "-o", "lstart=")
		startTime, err := psCmd.Output()
		if err != nil {
			log.Info().
				Str("master_pid", pid).
				Msg("nginx master process found")
		} else {
			log.Info().
				Str("master_pid", pid).
				Str("start_time", string(bytes.TrimSpace(startTime))).
				Msg("nginx master process info before reload")
		}
	}

	return nil
}

// CreateChallengeDir ensures the ACME challenge directory exists
func (nc *NginxConfig) CreateChallengeDir() error {
	challengeDir := nc.GetChallengeDir()
	if err := os.MkdirAll(challengeDir, 0755); err != nil {
		return fmt.Errorf("failed to create challenge directory: %w", err)
	}

	log.Debug().
		Str("challenge_dir", challengeDir).
		Msg("ACME challenge directory ensured")
	return nil
}
